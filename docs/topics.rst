Discussions
===========

Tokens design
-------------

django-sesame builds authentication tokens as follows:

- Encode the primary key of the user for which they were generated;
- If :data:`SESAME_MAX_AGE` is enabled, encode the token generation timestamp;
- Assemble a revocation key which is used for :ref:`invalidating tokens <Tokens
  invalidation>`;
- Add a message authentication code (MAC) to prevent tampering with the token.

Primary keys are in clear text. If this is a concern, you can write a
:ref:`custom packer <Custom primary keys>` to encrypt them.

The revocation key is derived from:

- The password of the user, unless :data:`SESAME_INVALIDATE_ON_PASSWORD_CHANGE`
  is disabled;
- The last login date of the user, if :data:`SESAME_ONE_TIME` is enabled.

django-sesame provides two token formats:

- :ref:`v1 <Tokens v1>` is the original format; it is still fully supported;
- :ref:`v2 <Tokens v2>` is a better, cleaner, faster design that produces
  shorter tokens.

:data:`SESAME_TOKENS` defaults to ``["sesame.tokens_v2", "sesame.tokens_v1"]``.

This means "generate tokens v2, accept tokens v2 and v1".

Tokens v2
.........

.. versionadded:: 2.0

Tokens v2 contain a primary key, an optional timestamp, and a signature.

The signature covers the primary key, the optional timestamp, and the
revocation key. If the revocation key changes, the signature becomes invalid.
As a consequence, there's no need to include the revocation key in tokens.

The signature algorithm is Blake2 in keyed mode. A unique key is derived by
hashing the :setting:`SECRET_KEY` setting and relevant django-sesame settings.

By default the signature length is 10 bytes. You can adjust it to any value
between 1 and 64 bytes with the :data:`SESAME_SIGNATURE_SIZE` setting.

Tokens v1
.........

Tokens v1 contain a primary key and a revocation key, plus an optional timestamp
and a signature generated by Django's :class:`~django.core.signing.Signer` or
:class:`~django.core.signing.TimestampSigner`. The signature algorithm is
HMAC-SHA1.

Tokens invalidation
-------------------

Once a token is created, you can invalidate it in several ways.

Invalid tokens are simply rejected. You may :ref:`enable logs to understand the
reason <How do I understand why a token is invalid?>`.

Expiration
..........

By default, tokens are valid forever. You can :ref:`configure expiration <Tokens
expiration>` to give them a finite lifetime.

When expiration is enabled, tokens store the time when they were created. When
authenticating them, django-sesame verifies how old they are.

.. admonition:: You can check if an invalid token is expired by
        re-authenticating it with a very large ``max_age``.
    :class: tip

    If that makes it valid, then it was expired.

Single-use
..........

By default, tokens can be reused. You can :ref:`enable single-use tokens
<Single-use tokens>` to invalidate them when they're used.

Single-use tokens are tied to the user's last login date. When authenticating a
single-use token successfully, django-sesame updates the user's last login date,
which invalidates the token.

As a consequence of this design:

* As soon as a user logs in, via django-sesame or via another login mechanism,
  all their single-use tokens become invalid.
* Authenticating a single-use token updates the user's last login date, even if
  the user isn't logged in permanently.

Finally, single-use tokens can easily get :ref:`invalidated by accident <Why do
one-time tokens sent by email fail?>`.

For all these reasons, tokens with a short lifetime are recommended over
single-use tokens.

Password change
...............

By default, tokens are tied to the users' passwords. Changing the password
invalidates the token.

Indeed, when there's a suspicion that an account may be compromised, changing
the password is the first step. Invalidating tokens makes sense in that case.

.. admonition:: Invalidation on password change is less needed when tokens expire
        quickly.
    :class: tip

    For example, if you rely on short-lived tokens to validate the email address
    in a sign up process and you don't know whether validation will occur before
    or after initializing the password, you need to disable invalidation. That's
    fine from a security perspective.

Since Django hashes the password with a random salt, the token is invalidated
even if the new password is identical to the old one.

When users log in with django-sesame only, they don't need a password. In that
case, you should set their passwords to a invalid value with
:meth:`~django.contrib.auth.models.User.set_unusable_password`. You can
invalidate a token at any time by calling
:meth:`~django.contrib.auth.models.User.set_unusable_password` again and saving
the user instance.

You can disable this behavior by setting
:data:`SESAME_INVALIDATE_ON_PASSWORD_CHANGE` to :obj:`False`.

.. admonition:: Disabling invalidation on password change makes it impossible to
        invalidate a single token.
    :class: warning

    If a token is compromised, your only options are to deactivate the user or
    to invalidate all tokens for all users.

Inactive user
.............

When the :attr:`~django.contrib.auth.models.CustomUser.is_active` attribute of a
user is set to :obj:`False`, django-sesame rejects their tokens.

Different settings
..................

You must generate tokens and authenticate them with the same :ref:`settings
<Settings>`.

There's a limited exception for :data:`SESAME_MAX_AGE`: as long as it isn't
:obj:`None`, you can change its value and tokens will remain valid.

If you need to invalidate all tokens, set the :data:`SESAME_KEY` setting to a
new value. This invalidates the signatures of all :ref:`tokens v2 <Tokens v2>`.
If you still have non-expired :ref:`tokens v1 <Tokens v1>`, do the same with
:data:`SESAME_SALT`.

Custom primary keys
-------------------

When generating a token for a user, django-sesame stores the user's primary key
in the token.

To keep tokens short, it creates a compact binary representations depending on
the type of the primary key.

If you're using integer or UUID primary keys, you're fine.

If you're using another type of primary key, for example a string created by a
unique ID generation algorithm, the default representation may be suboptimal.

For example, let's say primary keys are strings containing 24 hexadecimal
characters. The default packer represents them with 25 bytes. You can reduce
them to 12 bytes with this custom packer:

.. code-block:: python

    from sesame.packers import BasePacker

    class Packer(BasePacker):

        @staticmethod
        def pack_pk(user_pk):
            assert len(user_pk) == 24
            return bytes.fromhex(user_pk)

        @staticmethod
        def unpack_pk(data):
            return data[:12].hex(), data[12:]

Set the :data:`SESAME_PACKER` setting to the dotted Python path to the custom
packer class.

For details, see :class:`~sesame.packers.BasePacker` and look at built-in
packers defined in the ``sesame.packers`` module.

Safari issues
-------------

:class:`~sesame.middleware.AuthenticationMiddleware` removes the token from the
URL with an HTTP 302 Redirect after authenticating a user successfully.

Unfortunately, this triggers a false positive of Safari's `Protection Against
First Party Bounce Trackers`__. As a consequence, Safari clears cookies and the
user is logged out.

__ https://webkit.org/blog/8311/intelligent-tracking-prevention-2-0/

To avoid this problem, django-sesame doesn't redirect when it detects that the
browser is Safari. This relies on the `ua-parser`_ package, which is an optional
dependency. If ua-parser isn't installed, django-sesame always redirects.

.. _ua-parser: https://github.com/ua-parser/uap-python

Stateless authentication
------------------------

Theoretically, django-sesame can provide stateless authenticated navigation
without :mod:`django.contrib.sessions`, provided all internal links include the
authentication token.

When Django's :class:`~django.contrib.sessions.middleware.SessionMiddleware` and
:class:`~django.contrib.auth.middleware.AuthenticationMiddleware` aren't
configured, django-sesame's :class:`~sesame.middleware.AuthenticationMiddleware`
sets ``request.user`` to the logged-in user or
:class:`~django.contrib.auth.models.AnonymousUser`.

There is no clear use case for this. Better persist authentication in cookies
than in URLs.
